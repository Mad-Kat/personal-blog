import type React from "react";
import {
	Children,
	type ComponentProps,
	type FC,
	type ReactNode,
	useState,
} from "react";
import { base32 } from "rfc4648";
import styles from "./Totp.module.css";
import { useTOTP } from "./useTOTP";

export const Totp: React.FC = () => {
	const [inputSecret, setInputSecret] = useState<string>(
		"12345678901234567890",
	);
	const [inputDigits, setInputDigits] = useState<number>(6);
	const [algorithm, setAlgorithm] = useState<"SHA1" | "SHA256" | "SHA512">(
		"SHA1",
	);
	const [timeStep, setTimeStep] = useState<number>(30);
	const [t0, setT0] = useState<number>(0);
	const { totpValue, remainingSeconds, error, updateConfig, debug } = useTOTP({
		secret: base32.stringify(new TextEncoder().encode(inputSecret)),
		digits: inputDigits,
		algorithm: algorithm,
		step: timeStep,
		t0: t0,
	});

	const updateSecret = (event: React.ChangeEvent<HTMLInputElement>) => {
		const newSecret = event.target.value;

		setInputSecret(newSecret);
		updateConfig((oldConfig) => ({
			...oldConfig,
			secret: base32
				.stringify(new TextEncoder().encode(newSecret))
				.replaceAll("=", ""),
		}));
	};

	const updateT0 = (event: React.ChangeEvent<HTMLInputElement>) => {
		const newT0 = Number(event.target.value);

		setT0(newT0);
		updateConfig((oldConfig) => ({
			...oldConfig,
			t0: newT0,
		}));
	};

	const updateTimeStep = (event: React.ChangeEvent<HTMLInputElement>) => {
		const newTimeStep = Number(event.target.value);

		setTimeStep(newTimeStep);
		updateConfig((oldConfig) => ({
			...oldConfig,
			step: newTimeStep,
		}));
	};

	const updateAlgorithm = (event: React.ChangeEvent<HTMLSelectElement>) => {
		const newAlgorithm = event.target.value as "SHA1" | "SHA256" | "SHA512";

		setAlgorithm(newAlgorithm);
		updateConfig((oldConfig) => ({
			...oldConfig,
			algorithm: newAlgorithm,
		}));
	};

	const updateInputDigits = (event: React.ChangeEvent<HTMLSelectElement>) => {
		const newDigits = Number(event.target.value);

		setInputDigits(newDigits);
		updateConfig((oldConfig) => ({
			...oldConfig,
			digits: newDigits,
		}));
	};

	return (
		<>
			<h2>Generator</h2>
			<div
				style={{
					display: "flex",
					flexDirection: "column",
					gap: "1rem",
					maxWidth: "max-content",
					margin: "auto",
				}}
			>
				<Input
					label="Secret"
					id="generator-secret"
					value={inputSecret}
					onChange={updateSecret}
					maxLength={20}
				/>
				<div
					style={{
						display: "flex",
						gap: "1rem",
					}}
				>
					<Select
						label="Digits"
						id="generator-digits"
						value={inputDigits}
						onChange={updateInputDigits}
						options={["6", "7", "8"]}
						style={{
							flex: 1,
							maxWidth: "100%",
						}}
					/>
					<Select
						label="Algorithm"
						id="generator-algorithm"
						value={algorithm}
						onChange={updateAlgorithm}
						options={["SHA1", "SHA256", "SHA512"]}
						style={{
							flex: 1,
							maxWidth: "100%",
						}}
					/>
				</div>
				<div
					style={{
						display: "flex",
						gap: "1rem",
					}}
				>
					<Input
						label="Time step"
						id="generator-time-step"
						value={timeStep}
						onChange={updateTimeStep}
						min={1}
						maxLength={5}
					/>
					<Input
						label="Offset"
						id="generator-offset"
						value={t0}
						onChange={updateT0}
						min={0}
						maxLength={5}
					/>
				</div>
				<div
					style={{
						display: "flex",
						justifyContent: "center",
						marginTop: "2rem",
					}}
				>
					<TOTP
						otp={debug?.otp ?? "0000"}
						remainingSeconds={remainingSeconds}
						timeStep={timeStep}
					/>
				</div>
			</div>
			<h2>Explanation: How TOTP Works</h2>
			<h3>Secret key</h3>
			<p>
				TOTP has a few steps to generate the one-time password. The first step
				is to get a secret. This secret is a shared secret between the server
				and the client. The secret is usually generated by the server and
				displayed as a QR code to the user. The user can then scan the QR code
				with an authenticator app and the secret is stored in the app.
			</p>
			<Container>
				<Input label="Secret" value={inputSecret} onChange={updateSecret} />
				{/* <p>Todo: Add QRcode from here: https://stefansundin.github.io/2fa-qr/</p> */}
			</Container>
			<p>
				Afterwards the secret key is converted to base32 or directly created as
				base32 and shared between the server and the client.
			</p>
			<Container>
				<Input
					label="Base32"
					value={base32
						.stringify(new TextEncoder().encode(inputSecret))
						.replaceAll("=", "")}
					readonly
				/>
			</Container>
			<p>
				This is the standard encoding for TOTP and also recommended in the RFC
				but in theory any shared form would work because in order to work with,
				it needs to be converted into the binary representation.
			</p>
			<Container>
				<Input
					label="Bytes (hex)"
					value={debug?.secret_bytes ?? "0000"}
					readonly
				/>
			</Container>
			<h3>Time</h3>
			<p>
				That is the first part of the input. For the second part we need the
				(T)ime in TOTP expressed in seconds since the Unix epoch. For another
				layer of obscurity we can change the starting value (offset) of the time
				calculation and determine for how long (time step) the current TOTP code
				should be valid. The resulting time value is calculated by subtracting
				the offset and dividing the result by the time step.
			</p>
			<Container>
				<Input
					label="Current time"
					value={String(debug?.current_time ?? 0)}
					readonly
					style={{
						fontVariantNumeric: "tabular-nums",
					}}
				/>
				<p>-</p>
				<Input
					label="Offset"
					value={String(t0)}
					onChange={updateT0}
					min={0}
					maxLength={5}
					style={{
						maxWidth: "60px",
					}}
				/>
				<p>/</p>
				<Input
					label="Step"
					value={String(timeStep)}
					onChange={updateTimeStep}
					min={1}
					maxLength={5}
					style={{
						maxWidth: "60px",
					}}
				/>
				<p>=</p>
				<Input
					label="Time result"
					value={String(
						Math.round(((debug?.current_time ?? 0) - t0) / timeStep),
					)}
					readonly
				/>
			</Container>
			<p>
				And as before, the time is converted to bytes. This is done by
				converting the number to a 64 bit big endian integer.
			</p>
			<Container>
				<Input
					label="Time (hex)"
					value={debug?.time_bytes ?? "0000"}
					readonly
				/>
			</Container>
			<h3>Hashing</h3>
			<p>
				With both parts of the input ready, the next step is to hash the input.
				For that the two input parts are byte-wise concatenated before the hash
				function is applied.
			</p>
			<Container>
				<Input
					label="Concatinated input"
					value={debug?.hmac_input ?? "0000"}
					readonly
				/>
			</Container>
			<p>
				After the input is ready, the next step is to hash the input with one of
				three algorithms.
			</p>
			<Container>
				<Select
					label="Algorithm"
					value={algorithm}
					onChange={updateAlgorithm}
					options={["SHA1", "SHA256", "SHA512"]}
				/>
				<Input
					label="Hashed result"
					value={debug?.hmac_result ?? "0000"}
					readonly
				/>
			</Container>
			<p>
				If you played with the algorithm, you might have noticed that the output
				lenght is different for each algorithm but the TOTP output is a fixed
				sized output. Luckily the process accounts for these differences with
				the next steps.
			</p>
			<h3>Truncation</h3>
			<p>
				After we have generated the hashed output the next step is to get a
				number that is exactly 31 bits long (4 bytes with the highest bit set to
				0) to not fall into the signness trap of numbers. This number can
				represent values from 0 to 2'147'483'647, which is enough to cover the
				six up to eight digits of the TOTP output.
			</p>
			<p>
				To make the predictability of the output a bit better, the output of the
				hashing function is not directly truncated and converted to a number.
				Instead the last 4 bits of the last byte are used to determine the
				offset of the bytes that are used to create the number. This value can
				be between 0 and 15. Afterwards the bytes from the highest bit after the
				offset are taken and put into a 32 bit integer.
			</p>
			<Container>
				<Input label="Offset" value={String(debug?.offset ?? 0)} readonly />
				<p>-&#x3e;</p>
				<Input
					label="Truncated output"
					value={debug?.binary ?? "0000"}
					readonly
				/>
				<p>by</p>
				<Select
					label="Digits"
					value={String(inputDigits)}
					onChange={updateInputDigits}
					options={["6", "7", "8"]}
				/>
				<p>=</p>
				<Input label="TOTP" value={debug?.otp ?? "0000"} readonly />
			</Container>
			<p>
				Afterwards and also the last step is to truncate the number again to the
				desired number of digits. This is done by taking the lowest digits
				(base10) of the number. And there you have it. The TOTP is generated and
				can be used to verify the user.
			</p>
			<Container>
				<TOTP
					otp={debug?.otp ?? "0000"}
					remainingSeconds={remainingSeconds}
					timeStep={timeStep}
				/>
			</Container>
		</>
	);
};

const Container: FC<{ children?: ReactNode[] | ReactNode }> = ({
	children,
}) => {
	return (
		<div
			style={{
				display: "flex",
				justifyContent:
					children && Array.isArray(children) && children.length > 0
						? "space-evenly"
						: "center",
				alignItems: "center",
				marginBlock: "3rem",
			}}
		>
			{children}
		</div>
	);
};

const Input: FC<{
	label: string;
	id?: string;
	readonly?: boolean;
	value: string | number;
	onChange?: ComponentProps<"input">["onChange"];
	min?: number;
	maxLength?: number;
	style?: React.CSSProperties;
}> = ({ label, id, readonly, value, onChange, min, maxLength, style }) => {
	return (
		<div className={styles.container}>
			<label htmlFor={id ?? label} className={styles.label}>
				{label}
			</label>
			{readonly ? (
				<p
					style={{
						overflowWrap: "anywhere",
						...style,
					}}
				>
					{value}
				</p>
			) : (
				<input
					id={id ?? label}
					name={id ?? label}
					type="text"
					className={styles.input}
					value={value}
					onChange={onChange}
					min={min}
					maxLength={maxLength}
					style={style}
				/>
			)}
		</div>
	);
};

const Select: FC<{
	label: string;
	id?: string;
	value: string | number;
	onChange?: ComponentProps<"select">["onChange"];
	options: string[];
	style?: React.CSSProperties;
}> = ({ label, id, value, onChange, options, style }) => {
	return (
		<div
			className={styles.container}
			style={{
				minWidth: "max-content",
				maxWidth: "max-content",
				...style,
			}}
		>
			<label htmlFor={id ?? label} className={styles.label}>
				{label}
			</label>
			<select
				id={id ?? label}
				name={id ?? label}
				value={value}
				onChange={onChange}
				className={styles.select}
				style={{
					maxWidth: "max-content",
					...style,
				}}
			>
				{options.map((option) => (
					<option key={option}>{option}</option>
				))}
			</select>
		</div>
	);
};

const TOTP: FC<{
	otp?: string;
	remainingSeconds?: number;
	timeStep: number;
}> = ({ otp, remainingSeconds, timeStep }) => {
	return (
		<p
			style={{
				fontSize: "2.5rem",
				textAlign: "center",
				maxWidth: "max-content",
				// @ts-expect-error
				"--font-wght": "200",
			}}
		>
			{otp}
			<div
				style={{
					width: "100%",
					height: "1px",
				}}
			>
				<div
					style={{
						height: "100%",
						backgroundColor: "black",
						width: `${((remainingSeconds ?? 0) / timeStep) * 100}%`,
						transition: "width 1s linear",
					}}
				/>
			</div>
		</p>
	);
};
